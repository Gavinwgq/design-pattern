解释器模式是一种使用频率相对较低但学习难度较大的设计模式，它用于描述如何使用面向
对象语言构成一个简单的语言解释器。在某些情况下，为了更好地描述某一些特定类型的问
题，我们可以创建一种新的语言，这种语言拥有自己的表达式和结构，即文法规则，这些问
题的实例将对应为该语言中的句子。此时，可以使用解释器模式来设计这种新的语言。对解
释器模式的学习能够加深我们对面向对象思想的理解，并且掌握编程语言中文法规则的解释
过程。<br/>
解释器模式定义如下： 
>解释器模式(Interpreter Pattern)：定义一个语言的文法，并且建立一个
解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。解释器模式是
一种类行为型模式。

由于表达式可分为终结符表达式和非终结符表达式，因此解释器模式的结构与组合模式的结
构有些类似，但在解释器模式中包含更多的组成元素.<br/>
在解释器模式中包含如下几个角色：<br/>
* AbstractExpression（抽象表达式）：在抽象表达式中声明了抽象的解释操作，它是所有终结
符表达式和非终结符表达式的公共父类。
* TerminalExpression（终结符表达式）：终结符表达式是抽象表达式的子类，它实现了与文法
中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个
解释器模式中只有少数几个终结符表达式类，它们的实例可以通过非终结符表达式组成较为
复杂的句子。
* NonterminalExpression（非终结符表达式）：非终结符表达式也是抽象表达式的子类，它实
现了文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以
继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。
* Context（环境类）：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通
常它临时存储了需要解释的语句。

在解释器模式中，每一种终结符和非终结符都有一个具体类与之对应，正因为使用类来表示
每一条文法规则，所以系统将具有较好的灵活性和可扩展性。对于所有的终结符和非终结
符，我们首先需要抽象出一个公共父类，即抽象表达式类，其典型代码如下所示：
```
abstract class AbstractExpression {
public abstract void interpret(Context ctx);
}
```
终结符表达式和非终结符表达式类都是抽象表达式类的子类，对于终结符表达式，其代码很
简单，主要是对终结符元素的处理，其典型代码如下所示：
```
class TerminalExpression extends AbstractExpression {
    public void interpret(Context ctx) {
    //终结符表达式的解释操作
    }
}
```
对于非终结符表达式，其代码相对比较复杂，因为可以通过非终结符将表达式组合成更加复
杂的结构，对于包含两个操作元素的非终结符表达式类，其典型代码如下：
```
class NonterminalExpression extends AbstractExpression {
    private AbstractExpression left;
    private AbstractExpression right;
    public NonterminalExpression(AbstractExpression left,AbstractExpression right){
        this.left=left;
        this.right=right;
    }
    public void interpret(Context ctx) {
    //递归调用每一个组成部分的interpret()方法
    //在递归调用时指定组成部分的连接方式，即非终结符的功能
    }
}
```
除了上述用于表示表达式的类以外，通常在解释器模式中还提供了一个环境类Context，用于
存储一些全局信息，通常在Context中包含了一个HashMap或ArrayList等类型的集合对象（也可
以直接由HashMap等集合类充当环境类），存储一系列公共信息，如变量名与值的映射关系
（key/value）等，用于在进行具体的解释操作时从中获取相关信息。其典型代码片段如下：
```
class Context {
    private HashMap map = new HashMap();
    public void assign(String key, String value) {
    //往环境类中设值
    }
    public String lookup(String key) {
    //获取存储在环境类中的值
    }
}
```
当系统无须提供全局公共信息时可以省略环境类，可根据实际情况决定是否需要环境类。<br/>
在解释器模式中，环境类Context用于存储解释器之外的一些全局信息，它通常作为参数被传
递到所有表达式的解释方法interpret()中，可以在Context对象中存储和访问表达式解释器的状
态，向表达式解释器提供一些全局的、公共的数据，此外还可以在Context中增加一些所有表
达式解释器都共有的功能，减轻解释器的职责。<br/>
解释器模式为自定义语言的设计和实现提供了一种解决方案，它用于定义一组文法规则并通
过这组文法规则来解释语言中的句子。虽然解释器模式的使用频率不是特别高，但是它在正
则表达式、XML文档解释等领域还是得到了广泛使用。与解释器模式类似，目前还诞生了很
多基于抽象语法树的源代码处理工具，例如Eclipse中的Eclipse AST，它可以用于表示Java语言
的语法结构，用户可以通过扩展其功能，创建自己的文法规则。<br/>
1. **主要优点**<br/>
解释器模式的主要优点如下：<br/>
(1) 易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过
继承等机制来改变或扩展文法。<br/>
(2) 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。<br/>
(3) 实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类
的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。<br/>
(4) 增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新
的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”。<br/>
2. **主要缺点**<br/>
解释器模式的主要缺点如下：<br/>
(1) 对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一
个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考
虑使用语法分析程序等方式来取代解释器模式。<br/>
(2) 执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂
的句子时其速度很慢，而且代码的调试过程也比较麻烦。<br/>
3. **适用场景**<br/>
在以下情况下可以考虑使用解释器模式：<br/>
(1) 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。<br/>
(2) 一些重复出现的问题可以用一种简单的语言来进行表达。<br/>
(3) 一个语言的文法较为简单。<br/>
(4) 执行效率不是关键问题。【注：高效的解释器通常不是通过直接解释抽象语法树来实现
的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。】